/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/riot/riot.esm.js":
/*!***************************************!*\
  !*** ./node_modules/riot/riot.esm.js ***!
  \***************************************/
/*! exports provided: __, component, install, mount, register, uninstall, unmount, unregister, version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__\", function() { return __; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"component\", function() { return component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"install\", function() { return install; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mount\", function() { return mount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"register\", function() { return register; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uninstall\", function() { return uninstall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unmount\", function() { return unmount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unregister\", function() { return unregister; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* Riot v4.0.2, @license MIT */\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n      PLUGINS_SET = new Set(),\n      IS_DIRECTIVE = 'is',\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY,\n  PLUGINS_SET: PLUGINS_SET,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n\n/* eslint-disable fp/no-mutating-methods */\n/**\n * Throw an error\n * @param {string} error - error message\n * @returns {undefined} it's a IO void function\n */\n\nfunction panic(error) {\n  throw new Error(error);\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\n\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach((_ref) => {\n    let [key, value] = _ref;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n} // doese simply nothing\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\n\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return source;\n}\n/**\n * Normalize a DOM attribute that will be passed to a child component\n * @param   {string} attribute.name - attribute names might be dash case\n * @param   {*} attribute.value - sky is the limit\n * @returns {attribute} attribute object normalized\n */\n\nfunction normalizeAttribute(_ref2) {\n  let {\n    name,\n    value\n  } = _ref2;\n  return {\n    name: dashToCamelCase(name),\n    value: value\n  };\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach((_ref3) => {\n    let [key, value] = _ref3;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @param   {Object} scope - current scope\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes, scope) {\n  return attributes.reduce((acc, attribute) => {\n    const value = attribute.evaluate(scope); // spread attributes should be handled differently\n\n    if (!attribute.name) {\n      return Object.assign({}, acc, value);\n    }\n\n    const attr = normalizeAttribute({\n      value,\n      name: attribute.name\n    });\n    acc[attr.name] = attr.value;\n    return acc;\n  }, {});\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    const attr = normalizeAttribute(attribute);\n    acc[attr.name] = attr.value;\n    return acc;\n  }, {});\n}\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nfunction cleanNode(node) {\n  const children = node.childNodes;\n  Array.from(children).forEach(n => node.removeChild(n));\n}\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n/* get rid of the @ungap/essential-map polyfill */\n\nconst append = (get, parent, children, start, end, before) => {\n  if (end - start < 2) parent.insertBefore(get(children[start], 1), before);else {\n    const fragment = parent.ownerDocument.createDocumentFragment();\n\n    while (start < end) fragment.appendChild(get(children[start++], 1));\n\n    parent.insertBefore(fragment, before);\n  }\n};\n\nconst eqeq = (a, b) => a == b;\n\nconst identity = O => O;\n\nconst indexOf = (moreNodes, moreStart, moreEnd, lessNodes, lessStart, lessEnd, compare) => {\n  const length = lessEnd - lessStart;\n  /* istanbul ignore if */\n\n  if (length < 1) return -1;\n\n  while (moreEnd - moreStart >= length) {\n    let m = moreStart;\n    let l = lessStart;\n\n    while (m < moreEnd && l < lessEnd && compare(moreNodes[m], lessNodes[l])) {\n      m++;\n      l++;\n    }\n\n    if (l === lessEnd) return moreStart;\n    moreStart = m + 1;\n  }\n\n  return -1;\n};\n\nconst isReversed = (futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare) => {\n  while (currentStart < currentEnd && compare(currentNodes[currentStart], futureNodes[futureEnd - 1])) {\n    currentStart++;\n    futureEnd--;\n  }\n\n  return futureEnd === 0;\n};\n\nconst next = (get, list, i, length, before) => i < length ? get(list[i], 0) : 0 < i ? get(list[i - 1], -0).nextSibling : before;\n\nconst remove = (get, parent, children, start, end) => {\n  if (end - start < 2) parent.removeChild(get(children[start], -1));else {\n    const range = parent.ownerDocument.createRange();\n    range.setStartBefore(get(children[start], -1));\n    range.setEndAfter(get(children[end - 1], -1));\n    range.deleteContents();\n  }\n}; // - - - - - - - - - - - - - - - - - - -\n// diff related constants and utilities\n// - - - - - - - - - - - - - - - - - - -\n\n\nconst DELETION = -1;\nconst INSERTION = 1;\nconst SKIP = 0;\nconst SKIP_OND = 50;\n\nconst HS = (futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges) => {\n  let k = 0;\n  /* istanbul ignore next */\n\n  let minLen = futureChanges < currentChanges ? futureChanges : currentChanges;\n  const link = Array(minLen++);\n  const tresh = Array(minLen);\n  tresh[0] = -1;\n\n  for (let i = 1; i < minLen; i++) tresh[i] = currentEnd;\n\n  const keymap = new Map();\n\n  for (let i = currentStart; i < currentEnd; i++) keymap.set(currentNodes[i], i);\n\n  for (let i = futureStart; i < futureEnd; i++) {\n    const idxInOld = keymap.get(futureNodes[i]);\n\n    if (idxInOld != null) {\n      k = findK(tresh, minLen, idxInOld);\n      /* istanbul ignore else */\n\n      if (-1 < k) {\n        tresh[k] = idxInOld;\n        link[k] = {\n          newi: i,\n          oldi: idxInOld,\n          prev: link[k - 1]\n        };\n      }\n    }\n  }\n\n  k = --minLen;\n  --currentEnd;\n\n  while (tresh[k] > currentEnd) --k;\n\n  minLen = currentChanges + futureChanges - k;\n  const diff = Array(minLen);\n  let ptr = link[k];\n  --futureEnd;\n\n  while (ptr) {\n    const {\n      newi,\n      oldi\n    } = ptr;\n\n    while (futureEnd > newi) {\n      diff[--minLen] = INSERTION;\n      --futureEnd;\n    }\n\n    while (currentEnd > oldi) {\n      diff[--minLen] = DELETION;\n      --currentEnd;\n    }\n\n    diff[--minLen] = SKIP;\n    --futureEnd;\n    --currentEnd;\n    ptr = ptr.prev;\n  }\n\n  while (futureEnd >= futureStart) {\n    diff[--minLen] = INSERTION;\n    --futureEnd;\n  }\n\n  while (currentEnd >= currentStart) {\n    diff[--minLen] = DELETION;\n    --currentEnd;\n  }\n\n  return diff;\n}; // this is pretty much the same petit-dom code without the delete map part\n// https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L556-L561\n\n\nconst OND = (futureNodes, futureStart, rows, currentNodes, currentStart, cols, compare) => {\n  const length = rows + cols;\n  const v = [];\n  let d, k, r, c, pv, cv, pd;\n\n  outer: for (d = 0; d <= length; d++) {\n    /* istanbul ignore if */\n    if (d > SKIP_OND) return null;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    cv = v[d] = [];\n\n    for (k = -d; k <= d; k += 2) {\n      if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n        c = pv[pd + k + 1];\n      } else {\n        c = pv[pd + k - 1] + 1;\n      }\n\n      r = c - k;\n\n      while (c < cols && r < rows && compare(currentNodes[currentStart + c], futureNodes[futureStart + r])) {\n        c++;\n        r++;\n      }\n\n      if (c === cols && r === rows) {\n        break outer;\n      }\n\n      cv[d + k] = c;\n    }\n  }\n\n  const diff = Array(d / 2 + length / 2);\n  let diffIdx = diff.length - 1;\n\n  for (d = v.length - 1; d >= 0; d--) {\n    while (c > 0 && r > 0 && compare(currentNodes[currentStart + c - 1], futureNodes[futureStart + r - 1])) {\n      // diagonal edge = equality\n      diff[diffIdx--] = SKIP;\n      c--;\n      r--;\n    }\n\n    if (!d) break;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    k = c - r;\n\n    if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n      // vertical edge = insertion\n      r--;\n      diff[diffIdx--] = INSERTION;\n    } else {\n      // horizontal edge = deletion\n      c--;\n      diff[diffIdx--] = DELETION;\n    }\n  }\n\n  return diff;\n};\n\nconst applyDiff = (diff, get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before) => {\n  const live = new Map();\n  const length = diff.length;\n  let currentIndex = currentStart;\n  let i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        futureStart++;\n        currentIndex++;\n        break;\n\n      case INSERTION:\n        // TODO: bulk appends for sequential nodes\n        live.set(futureNodes[futureStart], 1);\n        append(get, parentNode, futureNodes, futureStart++, futureStart, currentIndex < currentLength ? get(currentNodes[currentIndex], 0) : before);\n        break;\n\n      case DELETION:\n        currentIndex++;\n        break;\n    }\n  }\n\n  i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        currentStart++;\n        break;\n\n      case DELETION:\n        // TODO: bulk removes for sequential nodes\n        if (live.has(currentNodes[currentStart])) currentStart++;else remove(get, parentNode, currentNodes, currentStart++, currentStart);\n        break;\n    }\n  }\n};\n\nconst findK = (ktr, length, j) => {\n  let lo = 1;\n  let hi = length;\n\n  while (lo < hi) {\n    const mid = (lo + hi) / 2 >>> 0;\n    if (j < ktr[mid]) hi = mid;else lo = mid + 1;\n  }\n\n  return lo;\n};\n\nconst smartDiff = (get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before) => {\n  applyDiff(OND(futureNodes, futureStart, futureChanges, currentNodes, currentStart, currentChanges, compare) || HS(futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges), get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before);\n};\n/*! (c) 2018 Andrea Giammarchi (ISC) */\n\n\nconst domdiff = (parentNode, // where changes happen\ncurrentNodes, // Array of current items/nodes\nfutureNodes, // Array of future items/nodes\noptions // optional object with one of the following properties\n//  before: domNode\n//  compare(generic, generic) => true if same generic\n//  node(generic) => Node\n) => {\n  if (!options) options = {};\n  const compare = options.compare || eqeq;\n  const get = options.node || identity;\n  const before = options.before == null ? null : get(options.before, 0);\n  const currentLength = currentNodes.length;\n  let currentEnd = currentLength;\n  let currentStart = 0;\n  let futureEnd = futureNodes.length;\n  let futureStart = 0; // common prefix\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentStart], futureNodes[futureStart])) {\n    currentStart++;\n    futureStart++;\n  } // common suffix\n\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentEnd - 1], futureNodes[futureEnd - 1])) {\n    currentEnd--;\n    futureEnd--;\n  }\n\n  const currentSame = currentStart === currentEnd;\n  const futureSame = futureStart === futureEnd; // same list\n\n  if (currentSame && futureSame) return futureNodes; // only stuff to add\n\n  if (currentSame && futureStart < futureEnd) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentStart, currentLength, before));\n    return futureNodes;\n  } // only stuff to remove\n\n\n  if (futureSame && currentStart < currentEnd) {\n    remove(get, parentNode, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  }\n\n  const currentChanges = currentEnd - currentStart;\n  const futureChanges = futureEnd - futureStart;\n  let i = -1; // 2 simple indels: the shortest sequence is a subsequence of the longest\n\n  if (currentChanges < futureChanges) {\n    i = indexOf(futureNodes, futureStart, futureEnd, currentNodes, currentStart, currentEnd, compare); // inner diff\n\n    if (-1 < i) {\n      append(get, parentNode, futureNodes, futureStart, i, get(currentNodes[currentStart], 0));\n      append(get, parentNode, futureNodes, i + currentChanges, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n      return futureNodes;\n    }\n  }\n  /* istanbul ignore else */\n  else if (futureChanges < currentChanges) {\n      i = indexOf(currentNodes, currentStart, currentEnd, futureNodes, futureStart, futureEnd, compare); // outer diff\n\n      if (-1 < i) {\n        remove(get, parentNode, currentNodes, currentStart, i);\n        remove(get, parentNode, currentNodes, i + futureChanges, currentEnd);\n        return futureNodes;\n      }\n    } // common case with one replacement for many nodes\n  // or many nodes replaced for a single one\n\n  /* istanbul ignore else */\n\n\n  if (currentChanges < 2 || futureChanges < 2) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, get(currentNodes[currentStart], 0));\n    remove(get, parentNode, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  } // the half match diff part has been skipped in petit-dom\n  // https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L391-L397\n  // accordingly, I think it's safe to skip in here too\n  // if one day it'll come out like the speediest thing ever to do\n  // then I might add it in here too\n  // Extra: before going too fancy, what about reversed lists ?\n  //        This should bail out pretty quickly if that's not the case.\n\n\n  if (currentChanges === futureChanges && isReversed(futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare)) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n    return futureNodes;\n  } // last resort through a smart diff\n\n\n  smartDiff(get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before);\n  return futureNodes;\n};\n\nconst EachBinding = Object.seal({\n  // dynamic binding properties\n  childrenMap: null,\n  node: null,\n  root: null,\n  condition: null,\n  evaluate: null,\n  template: null,\n  nodes: [],\n  getKey: null,\n  indexName: null,\n  itemName: null,\n  afterPlaceholder: null,\n  placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder\n    } = this;\n    const collection = this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n    const parent = placeholder.parentNode; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    if (futureNodes.length) {\n      domdiff(parent, this.nodes, futureNodes, {\n        before: placeholder,\n        node: patch(Array.from(this.childrenMap.values()), parentScope)\n      });\n    } else {\n      // remove all redundant templates\n      unmountRedundant(this.childrenMap);\n    } // trigger the mounts and the updates\n\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    unmountRedundant(this.childrenMap, parentScope);\n    this.childrenMap = new Map();\n    this.nodes = [];\n    return this;\n  }\n\n});\n/**\n * Patch the DOM while diffing\n * @param   {TemplateChunk[]} redundant - redundant tepmplate chunks\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      const {\n        template,\n        context\n      } = redundant.pop();\n      template.unmount(context, parentScope, false);\n    }\n\n    return item;\n  };\n}\n/**\n * Unmount the remaining template instances\n * @param   {Map} childrenMap - map containing the children template to unmount\n * @param   {*} parentScope - scope of the parent template\n * @returns {TemplateChunk[]} collection containing the template chunks unmounted\n */\n\n\nfunction unmountRedundant(childrenMap, parentScope) {\n  return Array.from(childrenMap.values()).map((_ref) => {\n    let {\n      template,\n      context\n    } = _ref;\n    return template.unmount(context, parentScope, true);\n  });\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? Boolean(condition(context)) === false : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref2) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref2;\n  scope[itemName] = item;\n  if (indexName) scope[indexName] = index;\n  return scope;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EeachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = oldItem ? componentTemplate.el : root.cloneNode();\n\n    if (!oldItem) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n\n\n    futureNodes.push(el); // delete the old item from the children map\n\n    childrenMap.delete(key); // update the children map\n\n    newChildrenMap.set(key, {\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create(node, _ref3) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref3;\n  const placeholder = document.createTextNode('');\n  const parent = node.parentNode;\n  const root = node.cloneNode();\n  const offset = Array.from(parent.childNodes).indexOf(node);\n  parent.insertBefore(placeholder, node);\n  parent.removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    offset,\n    condition,\n    evaluate,\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n/**\n * Binding responsible for the `if` directive\n */\n\n\nconst IfBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  evaluate: null,\n  placeholder: null,\n  template: '',\n\n  // API methods\n  mount(scope, parentScope) {\n    swap(this.placeholder, this.node);\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    switch (true) {\n      case mustMount:\n        swap(this.node, this.placeholder);\n\n        if (this.template) {\n          this.template = this.template.clone();\n          this.template.mount(this.node, scope, parentScope);\n        }\n\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        swap(this.placeholder, this.node);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    const {\n      template\n    } = this;\n\n    if (template) {\n      template.unmount(scope, parentScope);\n    }\n\n    return this;\n  }\n\n});\n\nfunction swap(inNode, outNode) {\n  const parent = outNode.parentNode;\n  parent.insertBefore(inNode, outNode);\n  parent.removeChild(outNode);\n}\n\nfunction create$1(node, _ref4) {\n  let {\n    evaluate,\n    template\n  } = _ref4;\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder: document.createTextNode(''),\n    template: template.createDOM(node)\n  });\n}\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nconst SET_ATTIBUTE = 'setAttribute';\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach((_ref5) => {\n    let [name, value] = _ref5;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing all the attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, attributes) {\n  Object.keys(attributes).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref6, value, oldValue) {\n  let {\n    name\n  } = _ref6;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value);\n    } else if (oldValue) {\n      // otherwise remove all the old attributes\n      removeAllAttributes(node, oldValue);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (typeof value === 'boolean') {\n    node[name] = value;\n  }\n\n  node[getMethod(value)](name, normalizeValue(name, value));\n}\n/**\n * Get the attribute modifier method\n * @param   {*} value - if truthy we return `setAttribute` othewise `removeAttribute`\n * @returns {string} the node attribute modifier method name\n */\n\n\nfunction getMethod(value) {\n  return value && typeof value !== 'object' ? SET_ATTIBUTE : REMOVE_ATTRIBUTE;\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  if (value === true) return name;\n  return value;\n}\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction eventExpression(node, _ref7, value) {\n  let {\n    name\n  } = _ref7;\n  node[name] = value;\n}\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {number} expression.childNodeIndex - index to find the text node to update\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction textExpression(node, _ref8, value) {\n  let {\n    childNodeIndex\n  } = _ref8;\n  const target = node.childNodes[childNodeIndex];\n  const val = normalizeValue$1(value); // replace the target if it's a placeholder comment\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode(val);\n    node.replaceChild(textNode, target);\n  } else {\n    target.data = normalizeValue$1(val);\n  }\n}\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\n\nfunction normalizeValue$1(value) {\n  return value != null ? value : '';\n}\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction valueExpression(node, expression, value) {\n  node.value = value;\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\nconst Expression = Object.seal({\n  // Static props\n  node: null,\n  value: null,\n\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    return this;\n  }\n\n});\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$2(node, data) {\n  return Object.assign({}, Expression, data, {\n    node\n  });\n}\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\n\n\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref9) {\n  let {\n    expressions\n  } = _ref9;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$2(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nconst SlotBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  name: null,\n  template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find((_ref10) => {\n      let {\n        id\n      } = _ref10;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    this.template = templateData && create$6(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      this.template.mount(this.node, parentScope);\n      moveSlotInnerContent(this.node);\n    }\n\n    parentNode.removeChild(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template && parentScope) {\n      this.template.update(parentScope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    if (this.template) {\n      this.template.unmount(parentScope);\n    }\n\n    return this;\n  }\n\n});\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLNode} slot - slot node\n * @returns {undefined} it's a void function\n */\n\nfunction moveSlotInnerContent(slot) {\n  if (slot.firstChild) {\n    slot.parentNode.insertBefore(slot.firstChild, slot);\n    moveSlotInnerContent(slot);\n  }\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} options.name - slot id\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref11) {\n  let {\n    name\n  } = _ref11;\n  return Object.assign({}, SlotBinding, {\n    node,\n    name\n  });\n}\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create$6(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref12) => {\n    let {\n      bindings\n    } = _ref12;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  evaluate: null,\n  name: null,\n  slots: null,\n  tag: null,\n  attributes: null,\n  getComponent: null,\n\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount() {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(true);\n    }\n\n    return this;\n  }\n\n});\n\nfunction create$4(node, _ref13) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref13;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$1,\n  [SIMPLE]: create$3,\n  [EACH]: create,\n  [TAG]: create$4,\n  [SLOT]: createSlot\n};\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {Object} binding - binding data\n * @returns {Expression} Expression object\n */\n\nfunction create$5(root, binding) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute); // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: expressions || []\n  }));\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n} // in this case a simple innerHTML is enough\n\n\nfunction createHTMLTree(html) {\n  const template = document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction creteSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return creteSVGTree(html, root);\n  return createHTMLTree(html);\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n// Ignore this helper because it's needed only for svg tags\n\n/* istanbul ignore next */\n\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n\nconst SVG_RE = /svg/i;\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {HTMLFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  if (SVG_RE.test(el.tagName)) {\n    moveChildren(dom, el);\n  } else {\n    el.appendChild(dom);\n  }\n}\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string} html - markup that will be injected into the root node\n * @returns {HTMLFragment} fragment that will be injected into the root node\n */\n\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  bindings: null,\n  bindingsData: null,\n  html: null,\n  dom: null,\n  el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html);\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope) {\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope);\n    this.el = el; // create the DOM if it wasn't created before\n\n    this.createDOM(el);\n    if (this.dom) injectDOM(el, this.dom.cloneNode(true)); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$5(this.el, binding));\n    this.bindings.forEach(b => b.mount(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean} mustRemoveRoot - if true remove the root element\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.el) {\n      this.bindings.forEach(b => b.unmount(scope, parentScope));\n      cleanNode(this.el);\n\n      if (mustRemoveRoot && this.el.parentNode) {\n        this.el.parentNode.removeChild(this.el);\n      }\n\n      this.el = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {Array} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create$6(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  shouldUpdate: noop,\n  onBeforeMount: noop,\n  onMounted: noop,\n  onBeforeUpdate: noop,\n  onUpdated: noop,\n  onBeforeUnmount: noop,\n  onUnmounted: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = {\n  update: noop,\n  mount: noop,\n  unmount: noop,\n  clone: noop,\n  createDOM: noop\n  /**\n   * Factory function to create the component templates only once\n   * @param   {Function} template - component template creation function\n   * @param   {Object} components - object containing the nested components\n   * @returns {TemplateChunk} template chunk object\n   */\n\n};\n\nfunction componentTemplateFactory(template, components) {\n  return template(create$6, expressionTypes, bindingTypes, name => {\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {string} options.css - component css\n * @param   {Function} options.template - functon that will return the dom-bindings template function\n * @param   {Object} options.exports - component interface\n * @param   {string} options.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(_ref) {\n  let {\n    css,\n    template,\n    exports,\n    name\n  } = _ref;\n  const templateFn = template ? componentTemplateFactory(template, exports ? createSubcomponents(exports.components) : {}) : MOCKED_TEMPLATE_INTERFACE;\n  return (_ref2) => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref3) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref3;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    state: {}\n  })), Object.assign({\n    // defined during the component creation\n    slots: null,\n    root: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Evaluate the component properties either from its real attributes or from its attribute expressions\n * @param   {HTMLElement} element - component root\n * @param   {Array}  attributeExpressions - attribute expressions generated by the riot compiler\n * @param   {Object} scope - current scope\n * @param   {Object} currentProps - current component properties\n * @returns {Object} attributes key value pairs\n */\n\nfunction evaluateProps(element, attributeExpressions, scope, currentProps) {\n  if (attributeExpressions === void 0) {\n    attributeExpressions = [];\n  }\n\n  if (currentProps === void 0) {\n    currentProps = {};\n  }\n\n  if (attributeExpressions.length) {\n    return scope ? evaluateAttributeExpressions(attributeExpressions, scope) : currentProps;\n  }\n\n  return DOMattributesToObject(element);\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\n\nfunction createAttributeBindings(attributes) {\n  return create$6(null, [{\n    expressions: (attributes || []).map(attr => {\n      return Object.assign({\n        type: expressionTypes.ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, 'is', name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref5) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref5;\n  const attributeBindings = createAttributeBindings(attributes);\n  const initialProps = callOrAssign(props);\n  return autobindMethods(runPlugins(defineProperties(Object.create(component), {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      this.props = Object.freeze(Object.assign({}, initialProps, evaluateProps(element, attributes, parentScope)));\n      this.state = computeState(this.state, state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone();\n      this[ATTRIBUTES_KEY_SYMBOL] = attributeBindings.clone(); // link this object to the DOM node\n\n      element[DOM_COMPONENT_INSTANCE_PROPERTY] = this; // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, 'root', element); // define the slots array\n\n      defineProperty(this, 'slots', slots); // before mount lifecycle event\n\n      this.onBeforeMount(this.props, this.state); // handlte the template and its attributes\n\n      this[ATTRIBUTES_KEY_SYMBOL].mount(element, parentScope);\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this.onMounted(this.props, this.state);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      const newProps = evaluateProps(this.root, attributes, parentScope, this.props);\n      if (this.shouldUpdate(newProps, this.props) === false) return;\n      this.props = Object.freeze(Object.assign({}, initialProps, newProps));\n      this.state = computeState(this.state, state);\n      this.onBeforeUpdate(this.props, this.state);\n\n      if (parentScope) {\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      this[TEMPLATE_KEY_SYMBOL].update(this, parentScope);\n      this.onUpdated(this.props, this.state);\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this.onBeforeUnmount(this.props, this.state);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount();\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, {}, !preserveRoot);\n      this.onUnmounted(this.props, this.state);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  PLUGINS_SET: PLUGINS_SET$1\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of nodes upgraded\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY$1]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY$1].unmount();\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET$1.has(plugin)) panic('This plugin was already install');\n  PLUGINS_SET$1.add(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET$1.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET$1.delete(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Helpter method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return (el, props) => compose(c => c.mount(el), c => c({\n    props\n  }), createComponent)(implementation);\n}\n/** @type {string} current riot version */\n\nconst version = 'v4.0.2'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  defineComponent,\n  globals\n};\n\n\n\n\n//# sourceURL=webpack:///./node_modules/riot/riot.esm.js?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _assets_styles_metatube_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assets/styles/metatube.scss */ \"./src/assets/styles/metatube.scss\");\n/* harmony import */ var _assets_styles_metatube_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_assets_styles_metatube_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var riot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! riot */ \"./node_modules/riot/riot.esm.js\");\n/* harmony import */ var _containers_landing_tag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./containers/landing.tag */ \"./src/containers/landing.tag\");\n\n\n\nObject(riot__WEBPACK_IMPORTED_MODULE_1__[\"component\"])(_containers_landing_tag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(document.querySelector('#app'));\n\n//# sourceURL=webpack:///./src/app.js?");

/***/ }),

/***/ "./src/assets/images/metatube_dark_01.png":
/*!************************************************!*\
  !*** ./src/assets/images/metatube_dark_01.png ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n\n//# sourceURL=webpack:///./src/assets/images/metatube_dark_01.png?");

/***/ }),

/***/ "./src/assets/styles/metatube.scss":
/*!*****************************************!*\
  !*** ./src/assets/styles/metatube.scss ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/assets/styles/metatube.scss?");

/***/ }),

/***/ "./src/components/about.tag":
/*!**********************************!*\
  !*** ./src/components/about.tag ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  'css': null,\n\n  'exports': {\n    onMounted() {\n      console.log('about tag mounted')\n    },\n\n    onUpdated() {\n      console.log('about tag has been updated')\n    }\n  },\n\n  'template': function(template, expressionTypes, bindingTypes, getComponent) {\n    return template('<h1>This is a test</h1>', []);\n  },\n\n  'name': 'about'\n});\n\n//# sourceURL=webpack:///./src/components/about.tag?");

/***/ }),

/***/ "./src/components/banner.tag":
/*!***********************************!*\
  !*** ./src/components/banner.tag ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _assets_images_metatube_dark_01_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assets/images/metatube_dark_01.png */ \"./src/assets/images/metatube_dark_01.png\");\n/* harmony import */ var _assets_images_metatube_dark_01_png__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_assets_images_metatube_dark_01_png__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  'css': null,\n\n  'exports': {\n    Logo: (_assets_images_metatube_dark_01_png__WEBPACK_IMPORTED_MODULE_0___default())\n  },\n\n  'template': function(template, expressionTypes, bindingTypes, getComponent) {\n    return template(\n      '<div class=\"flex mb-4\"><div class=\"w-full\"><img expr3 width=\"300px\" height=\"auto\" class=\"block\"/></div></div><div class=\"flex mb-4\"></div><h1 class>Banner</h1><button class=\"block m-auto bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded\">\\n    Button\\n  </button>',\n      [{\n        'redundantAttribute': 'expr3',\n        'selector': '[expr3]',\n\n        'expressions': [{\n          'type': expressionTypes.ATTRIBUTE,\n          'name': 'src',\n\n          'evaluate': function(scope) {\n            return scope.Logo;\n          }\n        }]\n      }]\n    );\n  },\n\n  'name': 'banner'\n});\n\n//# sourceURL=webpack:///./src/components/banner.tag?");

/***/ }),

/***/ "./src/components/sticky-footer.tag":
/*!******************************************!*\
  !*** ./src/components/sticky-footer.tag ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  'css': null,\n\n  'exports': {\n    onMounted() {\n      console.log('footer mounted')\n    }\n  },\n\n  'template': function(template, expressionTypes, bindingTypes, getComponent) {\n    return template(\n      '<div class=\"flex mb-4\"><div class=\"w-1/2 bg-gray-400 h-12\"></div><div class=\"w-1/2 bg-gray-500 h-12\"></div></div>',\n      []\n    );\n  },\n\n  'name': 'sticky-footer'\n});\n\n//# sourceURL=webpack:///./src/components/sticky-footer.tag?");

/***/ }),

/***/ "./src/containers/landing.tag":
/*!************************************!*\
  !*** ./src/containers/landing.tag ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_banner_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/banner.tag */ \"./src/components/banner.tag\");\n/* harmony import */ var _components_about_tag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/about.tag */ \"./src/components/about.tag\");\n/* harmony import */ var _components_sticky_footer_tag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/sticky-footer.tag */ \"./src/components/sticky-footer.tag\");\n\n\n\n\n\nconsole.log(_components_sticky_footer_tag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  'css': null,\n\n  'exports': {\n    components: {\n      Banner: _components_banner_tag__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n      About: _components_about_tag__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n      StickyFooter: _components_sticky_footer_tag__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n    },\n\n    onMounted() {\n      console.log('Landing mounted')\n    }\n  },\n\n  'template': function(template, expressionTypes, bindingTypes, getComponent) {\n    return template(\n      '<div class=\"flex-1 mx-auto w-full\"><banner expr0 class=\"flex-1 w-full h-full\"></banner><about expr1 class=\"flex-1 w-full h-full\"></about></div><sticky-footer expr2 class=\"w-full\"></sticky-footer>',\n      [{\n        'type': bindingTypes.TAG,\n        'getComponent': getComponent,\n\n        'evaluate': function(scope) {\n          return 'banner';\n        },\n\n        'slots': [],\n\n        'attributes': [{\n          'type': expressionTypes.ATTRIBUTE,\n          'name': 'class',\n\n          'evaluate': function() {\n            return 'flex-1 w-full h-full';\n          }\n        }],\n\n        'redundantAttribute': 'expr0',\n        'selector': '[expr0]'\n      }, {\n        'type': bindingTypes.TAG,\n        'getComponent': getComponent,\n\n        'evaluate': function(scope) {\n          return 'about';\n        },\n\n        'slots': [],\n\n        'attributes': [{\n          'type': expressionTypes.ATTRIBUTE,\n          'name': 'class',\n\n          'evaluate': function() {\n            return 'flex-1 w-full h-full';\n          }\n        }],\n\n        'redundantAttribute': 'expr1',\n        'selector': '[expr1]'\n      }, {\n        'type': bindingTypes.TAG,\n        'getComponent': getComponent,\n\n        'evaluate': function(scope) {\n          return 'sticky-footer';\n        },\n\n        'slots': [],\n\n        'attributes': [{\n          'type': expressionTypes.ATTRIBUTE,\n          'name': 'class',\n\n          'evaluate': function() {\n            return 'w-full';\n          }\n        }],\n\n        'redundantAttribute': 'expr2',\n        'selector': '[expr2]'\n      }]\n    );\n  },\n\n  'name': 'landing'\n});\n\n//# sourceURL=webpack:///./src/containers/landing.tag?");

/***/ })

/******/ });